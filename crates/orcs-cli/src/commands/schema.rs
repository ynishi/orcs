use anyhow::{Context, Result};
use orcs_core::schema::{
    ConversationModeType, ExecutionModelType, PresetSourceType, SessionType, TalkStyleType,
    TaskStatus, TaskType,
};
use orcs_core::session::{
    AppMode, AutoChatConfig, ConversationMessage, ConversationMode, ErrorSeverity, MessageMetadata,
    MessageRole, Plan, SandboxState, StopCondition, SystemEventType,
};
use orcs_core::state::model::{AppState, OpenTab};
use orcs_core::workspace::model::{
    ProjectContext, TempFile, UploadedFile, Workspace, WorkspaceResources,
};
use schema_bridge::SchemaBridge;
use std::env;
use std::fs;
use std::path::PathBuf;

pub fn generate() -> Result<()> {
    // Get the workspace root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")
        .context("CARGO_MANIFEST_DIR not set. Run from cargo or set manually.")?;
    let manifest_path = PathBuf::from(&manifest_dir);

    // Navigate to workspace root (crates/orcs-cli -> crates -> root)
    let workspace_root = manifest_path
        .parent()
        .and_then(|p| p.parent())
        .context("Failed to find workspace root")?;

    // Target path: orcs-desktop/src/bindings/generated.ts
    let output_dir = workspace_root
        .join("orcs-desktop")
        .join("src")
        .join("bindings");
    let output_file = output_dir.join("generated.ts");

    // Create output directory if it doesn't exist
    fs::create_dir_all(&output_dir).context("Failed to create bindings directory")?;

    println!("Generating TypeScript types...");
    println!("Output: {}", output_file.display());

    let types = vec![
        // Core types
        ("TalkStyleType", TalkStyleType::to_ts()),
        ("ExecutionModelType", ExecutionModelType::to_ts()),
        ("ConversationModeType", ConversationModeType::to_ts()),
        ("PresetSourceType", PresetSourceType::to_ts()),
        // App State types
        ("AppState", AppState::to_ts()),
        ("OpenTab", OpenTab::to_ts()),
        // Message types
        ("MessageRole", MessageRole::to_ts()),
        ("SystemEventType", SystemEventType::to_ts()),
        ("ErrorSeverity", ErrorSeverity::to_ts()),
        ("MessageMetadata", MessageMetadata::to_ts()),
        ("ConversationMessage", ConversationMessage::to_ts()),
        // App Mode types
        ("Plan", Plan::to_ts()),
        ("AppMode", AppMode::to_ts()),
        ("ConversationMode", ConversationMode::to_ts()),
        // Session types
        ("AutoChatConfig", AutoChatConfig::to_ts()),
        ("StopCondition", StopCondition::to_ts()),
        ("SandboxState", SandboxState::to_ts()),
        // Workspace types
        ("Workspace", Workspace::to_ts()),
        ("WorkspaceResources", WorkspaceResources::to_ts()),
        ("UploadedFile", UploadedFile::to_ts()),
        ("ProjectContext", ProjectContext::to_ts()),
        ("TempFile", TempFile::to_ts()),
        // Session metadata type (excludes persona_histories and system_messages)
        ("SessionType", SessionType::to_ts()),
        // Task types
        ("TaskType", TaskType::to_ts()),
        ("TaskStatus", TaskStatus::to_ts()),
    ];

    // Write to file
    let mut content =
        String::from("// Auto-generated TypeScript types from Rust using schema-bridge\n");
    content.push_str("// DO NOT EDIT MANUALLY\n");
    content.push_str("// Generated by: orcs schema generate\n\n");

    for (name, ts_def) in &types {
        content.push_str(&format!("export type {} = {};\n\n", name, ts_def));
    }

    fs::write(&output_file, content).context("Failed to write TypeScript types")?;

    println!("TypeScript types generated successfully!");
    println!("Total types: {}", types.len());

    Ok(())
}
