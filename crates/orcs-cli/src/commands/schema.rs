use anyhow::{Context, Result};
use orcs_core::schema::{
    ConversationModeType, ExecutionModelType, PresetSourceType, SessionType, TalkStyleType,
    TaskStatus, TaskType,
};
use orcs_core::session::{
    AppMode, AutoChatConfig, ConversationMessage, ConversationMode, ErrorSeverity, MessageMetadata,
    MessageRole, Plan, SandboxState, StopCondition, SystemEventType,
};
use orcs_core::state::model::{AppState, OpenTab};
use orcs_core::workspace::model::{
    ProjectContext, TempFile, UploadedFile, Workspace, WorkspaceResources,
};
use schema_bridge::SchemaBridge;
use std::env;
use std::fs;
use std::path::PathBuf;

pub fn generate() -> Result<()> {
    // Get the workspace root
    let manifest_dir = env::var("CARGO_MANIFEST_DIR")
        .context("CARGO_MANIFEST_DIR not set. Run from cargo or set manually.")?;
    let manifest_path = PathBuf::from(&manifest_dir);

    // Navigate to workspace root (crates/orcs-cli -> crates -> root)
    let workspace_root = manifest_path
        .parent()
        .and_then(|p| p.parent())
        .context("Failed to find workspace root")?;

    // Target path: orcs-desktop/src/bindings/generated.ts
    let output_dir = workspace_root
        .join("orcs-desktop")
        .join("src")
        .join("bindings");
    let output_file = output_dir.join("generated.ts");

    // Create output directory if it doesn't exist
    fs::create_dir_all(&output_dir).context("Failed to create bindings directory")?;

    println!("Generating TypeScript types...");
    println!("Output: {}", output_file.display());

    let mut types = Vec::new();

    // Core types
    types.push(("TalkStyleType", TalkStyleType::to_ts()));
    types.push(("ExecutionModelType", ExecutionModelType::to_ts()));
    types.push(("ConversationModeType", ConversationModeType::to_ts()));
    types.push(("PresetSourceType", PresetSourceType::to_ts()));

    // App State types
    types.push(("AppState", AppState::to_ts()));
    types.push(("OpenTab", OpenTab::to_ts()));

    // Message types
    types.push(("MessageRole", MessageRole::to_ts()));
    types.push(("SystemEventType", SystemEventType::to_ts()));
    types.push(("ErrorSeverity", ErrorSeverity::to_ts()));
    types.push(("MessageMetadata", MessageMetadata::to_ts()));
    types.push(("ConversationMessage", ConversationMessage::to_ts()));

    // App Mode types
    types.push(("Plan", Plan::to_ts()));
    types.push(("AppMode", AppMode::to_ts()));
    types.push(("ConversationMode", ConversationMode::to_ts()));

    // Session types
    types.push(("AutoChatConfig", AutoChatConfig::to_ts()));
    types.push(("StopCondition", StopCondition::to_ts()));
    types.push(("SandboxState", SandboxState::to_ts()));

    // Workspace types
    types.push(("Workspace", Workspace::to_ts()));
    types.push(("WorkspaceResources", WorkspaceResources::to_ts()));
    types.push(("UploadedFile", UploadedFile::to_ts()));
    types.push(("ProjectContext", ProjectContext::to_ts()));
    types.push(("TempFile", TempFile::to_ts()));

    // Session metadata type (excludes persona_histories and system_messages)
    types.push(("SessionType", SessionType::to_ts()));

    // Task types
    types.push(("TaskType", TaskType::to_ts()));
    types.push(("TaskStatus", TaskStatus::to_ts()));

    // Write to file
    let mut content =
        String::from("// Auto-generated TypeScript types from Rust using schema-bridge\n");
    content.push_str("// DO NOT EDIT MANUALLY\n");
    content.push_str("// Generated by: orcs schema generate\n\n");

    for (name, ts_def) in &types {
        content.push_str(&format!("export type {} = {};\n\n", name, ts_def));
    }

    fs::write(&output_file, content).context("Failed to write TypeScript types")?;

    println!("TypeScript types generated successfully!");
    println!("Total types: {}", types.len());

    Ok(())
}
